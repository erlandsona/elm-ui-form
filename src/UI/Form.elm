module UI.Form exposing
    ( Model, showErrors
    , init, bool, int, str
    , remove
    , Prop
    , checkbox, underlined
    , Config, field, kind, parser, floatError
    -- , Key, key
    -- , get, get_, getBool, getBool_, getInt, getList
    -- , set, setBool, setInt
    )

{-| Form Builder


# Model

@docs Model, showErrors
@docs init, bool, int, str
@docs get, get_, getBool, getBool_, getInt, getList
@docs set, setBool, setInt
@docs remove
@docs Prop
@docs Key, key


# View

@docs checkbox, underlined


# Builder (for underlined)

@docs Config, field, kind, parser, floatError

-}

import Accessors as A exposing (Lens, Relation, get, name, over, set)
import Dict exposing (Dict)
import Element.WithContext as E
import Element.WithContext.Events as Event
import Element.WithContext.Font as Font
import Element.WithContext.Input as Input
import Gen.Lens as Lens
import Style.Color as Color
import Style.Size as Size
import UI exposing (Attributes, Element)
import UI.Field as Field
import Util.Bool as BoolUtil
import Util.Fn exposing (flip)
import Util.List as ListUtil
import Util.Maybe as MaybeUtil
import Util.String as StringUtil



{- TODO: Unify Form field definitions under a real form object via a validator
   so that this value is more than just a Phantom.
-}


type Model value
    = Model Internal


c_Model : Lens (Model value) wrap Internal reachable
c_Model =
    let
        g (Model i) =
            i
    in
    A.makeOneToOne "_Model" g (\fn -> g >> fn >> Model)


type alias Internal =
    { -- NOTE: use Result String String
      -- if parse errors need to be aggregated for display in a toast or something.
      -- data : Maybe value
      form : Dict String String
    , idPrefix : String
    , showErrors : Bool
    }


formL : Lens (Model value) wrap (Dict String String) reachable
formL =
    c_Model << Lens.form


{-| Form.init Dict.empty

type Msg
= Updated (Form.Model out)

init

update msg model =
Updated newForm ->
{ model | form = newForm }

view : Model -> Element Msg
view model =
input "some-page" TextField.underlined
{ label = "My Field"
}

-}
init :
    { idPrefix : String
    }
    -> Model value
init { idPrefix } =
    Model
        { form = Dict.empty
        , idPrefix = idPrefix
        , showErrors = False
        }


{-| Prop short for Property is a shorthand used mostly as a convenience in the defintion
of this module. But you get one by using the functions generated by `npm run dev:gen`
that populate the Gen.Lens module. You use them here like so

    > import Accessors exposing (get, set, over, try, onEach)
    > import Gen.Lens as Lens
    > Lens.data << try << Lens.email

-}
type alias Prop value field wrap =
    Relation field field field
    -> Relation value field wrap



-- type alias Traversal value reachable wrap =
--     Relation (Dict String String) reachable wrap
--     -> Relation (Model value) reachable wrap


str : Prop value field wrap -> Lens (Model value) wrap_ (Maybe String) path
str lens =
    formL << A.dictEntry (name lens)


int :
    Prop value field wrap
    -- -> Relation (Maybe Int) reachable a
    -- -> Relation (Model value) reachable a
    -> Lens (Model value) wrap_ (Maybe Int) path
int lens =
    A.makeOneToOne (name lens)
        (get (formL << A.dictEntry (name lens))
            >> Maybe.andThen String.toInt
        )
        (\fn ->
            over (formL << A.dictEntry (name lens))
                (Maybe.andThen String.toInt
                    >> fn
                    >> Maybe.map String.fromInt
                )
        )


bool :
    Prop value field wrap
    -- Relation (Maybe Bool) reachable a
    -- -> Relation (Model value) reachable a
    -> Lens (Model value) wrap_ (Maybe Bool) path
bool lens =
    A.makeOneToOne (name lens)
        (get (formL << A.dictEntry (name lens))
            >> Maybe.andThen BoolUtil.fromString
        )
        (\fn ->
            over (formL << A.dictEntry (name lens))
                (Maybe.andThen BoolUtil.fromString
                    >> fn
                    >> Maybe.map BoolUtil.toString
                )
        )



-- list : Prop (Model value) field wrap -> Prop value field wrap -> Prop (Model value) (List field) wrap
-- list formL


remove : Prop value field wrap -> Model value -> Model value
remove lens (Model i) =
    Model (over Lens.form (Dict.remove (name lens)) i)


showErrors : Model value -> Model value
showErrors (Model i) =
    Model (A.set Lens.showErrors True i)



-- View


checkbox :
    List (E.Attribute ctx Never)
    ->
        { icon : Bool -> E.Element ctx (Model value)
        , label : Input.Label ctx (Model value)
        , key : Prop value field wrap
        }
    -> Model value
    -> E.Element ctx (Model value)
checkbox attrs config (Model f) =
    let
        key_ : String
        key_ =
            name config.key

        id : String
        id =
            f.idPrefix ++ "-" ++ StringUtil.dasherize key_
    in
    Input.checkbox
        (UI.id id
            :: (attrs |> List.map (E.mapAttribute never))
        )
        { onChange =
            \b ->
                set (formL << A.dictEntry (name config.key))
                    (BoolUtil.toString b |> Just)
                    (Model f)
        , checked =
            get (formL << A.dictEntry (name config.key))
                (Model f)
                |> Maybe.andThen BoolUtil.fromString
                |> Maybe.withDefault False
        , icon = config.icon
        , label = config.label
        }


type alias Config value field wrap =
    { description : Field.Description

    -- TODO: Generalize so Form can handle nested Structures
    , key : Prop value field wrap
    , parser : String -> Result String field
    , kind : Field.Config (Model value)
    , floatErrors : Bool
    }


field :
    { description : Field.Description
    , key : Prop value field wrap
    , parser : String -> Result String field
    }
    -> Config value field wrap
field c =
    { description = c.description
    , key = c.key
    , parser = c.parser
    , kind = Field.text
    , floatErrors = False
    }


parser : (String -> Result String field) -> Config value field wrap -> Config value field wrap
parser =
    A.set Lens.parser


kind : Field.Config (Model value) -> Config value field wrap -> Config value field wrap
kind =
    A.set Lens.kind


floatError : Config value field wrap -> Config value field wrap
floatError =
    A.set Lens.floatErrors True


underlined :
    Model value
    -> Attributes Never
    -> Config value field wrap
    -> Element (Model value)
underlined (Model f_) attrs config =
    let
        key_ : String
        key_ =
            name config.key

        id : String
        id =
            f.idPrefix ++ "-" ++ StringUtil.dasherize key_

        validated : Internal -> Internal
        validated =
            BoolUtil.when (Dict.get key_ f_.form == Nothing || f_.showErrors)
                (over Lens.form (Dict.update key_ (MaybeUtil.orElse (Just ""))))

        f : Internal
        f =
            if f_.showErrors then
                f_ |> validated

            else
                f_

        value_ : Maybe String
        value_ =
            Dict.get key_ f.form

        parsed : Maybe (Result String field)
        parsed =
            Maybe.map config.parser value_

        valid : Bool
        valid =
            case parsed of
                Just (Ok _) ->
                    True

                Just (Err _) ->
                    False

                Nothing ->
                    True
    in
    if config.floatErrors then
        Field.underlined
            (UI.id id
                :: Event.onLoseFocus (Model (validated f))
                :: E.below (errors id [ E.moveDown 4 ] parsed)
                :: (attrs |> List.map (E.mapAttribute never))
            )
            config.description
            (config.kind |> Field.isValid valid)
            (\val -> set (formL << A.dictEntry (name config.key)) (Just val) (Model f))
            (value_ |> Maybe.withDefault "")

    else
        E.column (attrs |> List.map (E.mapAttribute never))
            [ Field.underlined
                [ UI.id id
                , Event.onLoseFocus (Model (validated f))
                ]
                config.description
                (config.kind |> Field.isValid valid)
                (\val -> set (formL << A.dictEntry (name config.key)) (Just val) (Model f))
                (value_ |> Maybe.withDefault "")
            , errors id [] parsed
            ]


errors : String -> Attributes msg -> Maybe (Result String field) -> Element msg
errors id overrides parsed =
    case parsed of
        Just (Err e) ->
            errorRow (UI.id (id ++ "-err") :: overrides) e

        _ ->
            errorRow overrides
                (Char.fromCode 127
                    -- Blank character to match height of
                    -- potential error
                    |> String.fromChar
                )


errorRow : Attributes msg -> String -> Element msg
errorRow overrides errorMsg =
    E.el
        (Font.color (Color.toUI Color.redValue)
            :: UI.fontSize Size.xsmall
            :: overrides
        )
        (E.text errorMsg)
